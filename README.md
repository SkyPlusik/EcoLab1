# Блочная сортировка / Bucket sort

**1 Общая постановка задачи**

Необходимо создать новый компонент для калькулятора, реализующий интерфейс с методом блочной сортировки массивов. Интерфейс должен поддерживать работу с разными типами данных: int, long, float, double, long double.

**2 Реализуемый алгоритм блочная сортировка**

Bucket Sort (блочная сортировка) — алгоритм распределяющей сортировки, который работает путем распределения элементов входного массива по нескольким "блокам" (buckets), с последующей индивидуальной сортировкой каждого блока и объединением результатов.

_Ключевая идея:_

1) Создать k пустых блоков (списков)
2) Для каждого элемента массива вычислить индекс блока, в который он должен быть помещен, и добавить элемент в этот блок
3) Отсортировать каждый блок индивидуально
4) Обойти все блоки в порядке возрастания их индексов и объединить их элементы в итоговый отсортированный массив

**3 Асимптотика**

n — количество элементов, k — количество блоков

Временная сложность:

Лучший случай: O(n + k) — когда данные равномерно распределены по всем блокам

Средний случай: O(n + k) — когда данные распределены достаточно равномерно

Худший случай: O(n²) — когда все элементы попадают в один блок

Сложность по памяти: O(n + k) 

**4 Реализация (псевдокод)**
```
void bucketSort(float arr[], int n) {
    // 1) Create n empty buckets
    vector<float> b[n];
    // 2) Put array elements in different buckets
    for (int i = 0; i < n; i++) {
        int bi = n * arr[i];
        b[bi].push_back(arr[i]);
    }
    // 3) Sort individual buckets using insertion sort
    for (int i = 0; i < n; i++) insertionSort(b[i]);
    // 4) Concatenate all buckets into arr[]
    int index = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < b[i].size(); j++) arr[index++] = b[i][j];
}
```
**5 Пример работы**

Программа реализует два вида сортировки: с заданным k и с вычисленным по формуле: k = sqrt(n), а также работает с типами данных int, long, float, double, long double.
<img width="578" height="561" alt="image" src="https://github.com/user-attachments/assets/4ebb9d31-1075-4611-9f87-ab2698ce013a" />
<img width="968" height="825" alt="image" src="https://github.com/user-attachments/assets/fd7853db-5b83-4009-9276-7e7b0495d334" />

**6 Сравнение с qsort из библиотеки stdlib**

Сравнение происходило для следующих типов данных: int, long, float, double, long double. Алгоритмы тестировались на наборах данных разного объема: 1, 10, 100, 1000, 2000, 5000, 6000, 7000, 8000 элементов. Для обеспечения статистической значимости результат усреднялся по 1000 запусков, а время выполнения замерялся в миллисекундах.

_Результаты вывода программы:_

<img width="465" height="831" alt="image" src="https://github.com/user-attachments/assets/401531b8-4000-49c8-b431-c798d1096f93" />
<img width="406" height="548" alt="image" src="https://github.com/user-attachments/assets/aa6fe6ea-681b-4beb-8658-40ea7e7ea36a" />

<img width="761" height="585" alt="image" src="https://github.com/user-attachments/assets/01693d19-ca44-48c6-ba11-df116222f8a0" />
<img width="700" height="431" alt="image" src="https://github.com/user-attachments/assets/6237c007-e585-4350-8d88-44a8d8e63084" />

**7 Выводы**

1) Разработанный алгоритм блочной сортировки демонстрирует лучшую производительность по сравнению с qsort для всех тестируемых типов данных, особенно на больших размерах массивов (5000+ элементов). На маленьких массивах (до 1000 элементов) разница в производительности незначительна, однако с ростом размера массива преимущество BucketSort становится очевидным.
2) Разработанный алгоритм успешно работает с различными типами данных, сохраняя стабильную производительность.
3) BucketSort особенно эффективен для данных с равномерным распределением, что делает его предпочтительным выбором для конкретных классов задач, где qsort может уступать в производительности.



